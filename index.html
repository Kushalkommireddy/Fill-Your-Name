<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Water Fill</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    font-family: 'Inter', sans-serif;
  }

  #canvas-wrap {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas { display: block; }

  #bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    padding: 16px 24px;
    background: rgba(0,0,0,0.75);
    backdrop-filter: blur(14px);
    border-top: 1px solid rgba(255,255,255,0.08);
    flex-wrap: wrap;
  }

  .word-tabs {
    display: flex;
    gap: 6px;
  }

  .tab {
    padding: 8px 18px;
    border: 1.5px solid rgba(255,255,255,0.25);
    background: transparent;
    color: rgba(255,255,255,0.55);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 17px;
    letter-spacing: 3px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
  }
  .tab:hover { border-color: #fff; color: #fff; }
  .tab.active {
    background: #fff;
    color: #000;
    border-color: #fff;
  }

  .custom-wrap {
    display: flex;
    align-items: center;
    gap: 0;
    border: 1.5px solid rgba(255,255,255,0.25);
    border-radius: 4px;
    overflow: hidden;
    transition: border-color 0.2s;
  }
  .custom-wrap:focus-within { border-color: #fff; }

  #custom-input {
    background: transparent;
    border: none;
    outline: none;
    color: #fff;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 17px;
    letter-spacing: 3px;
    padding: 8px 14px;
    width: 140px;
    caret-color: #fff;
  }
  #custom-input::placeholder { color: rgba(255,255,255,0.25); letter-spacing: 2px; }

  #custom-btn {
    background: rgba(255,255,255,0.08);
    border: none;
    border-left: 1.5px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.6);
    padding: 8px 12px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.2s;
  }
  #custom-btn:hover { background: rgba(255,255,255,0.18); color: #fff; }

  .divider {
    width: 1px;
    height: 36px;
    background: rgba(255,255,255,0.12);
  }

  .colors-wrap {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .color-label {
    color: rgba(255,255,255,0.4);
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .swatch {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.5);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: transform 0.2s, box-shadow 0.2s;
    flex-shrink: 0;
  }
  .swatch:hover {
    transform: scale(1.15);
  }
  .swatch input[type="color"] {
    position: absolute;
    inset: -6px;
    opacity: 0;
    cursor: pointer;
    width: calc(100% + 12px);
    height: calc(100% + 12px);
  }

  .arrow { color: rgba(255,255,255,0.3); font-size: 14px; }

  #fill-btn {
    padding: 9px 26px;
    border: 1.5px solid #fff;
    background: transparent;
    color: #fff;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 19px;
    letter-spacing: 4px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
    white-space: nowrap;
  }
  #fill-btn:hover { background: #fff; color: #000; }
  #fill-btn.reset { border-color: #ff4444; color: #ff4444; }
  #fill-btn.reset:hover { background: #ff4444; color: #fff; }

  #flash {
    position: fixed;
    inset: 0;
    background: rgba(255,255,255,0);
    pointer-events: none;
    transition: background 0.08s;
    z-index: 50;
  }

  #toast {
    position: fixed;
    top: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(-60px);
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    backdrop-filter: blur(12px);
    color: #fff;
    padding: 10px 22px;
    border-radius: 30px;
    font-size: 13px;
    letter-spacing: 1px;
    transition: transform 0.35s cubic-bezier(.34,1.56,.64,1);
    z-index: 100;
    white-space: nowrap;
  }
  #toast.show { transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

<div id="flash"></div>
<div id="toast"></div>

<div id="canvas-wrap">
  <canvas id="c"></canvas>
</div>

<div id="bar">

  <div class="word-tabs">
    <button class="tab active" data-word="VIRAT">VIRAT</button>
    <button class="tab" id="custom-tab" data-word="">CUSTOM</button>
  </div>

  <div class="custom-wrap" id="custom-wrap" style="display:none">
    <input type="text" id="custom-input" placeholder="TYPE WORD" maxlength="10" autocomplete="off" spellcheck="false">
    <button id="custom-btn" title="Apply">↵</button>
  </div>

  <div class="divider"></div>

  <div class="colors-wrap">
    <span class="color-label">Color</span>
    <div class="swatch" id="sw1" style="background:#00e5ff">
      <input type="color" id="c1" value="#00e5ff">
    </div>
    <span class="arrow">→</span>
    <div class="swatch" id="sw2" style="background:#0055ff">
      <input type="color" id="c2" value="#0055ff">
    </div>
  </div>

  <div class="divider"></div>

  <button id="fill-btn">FILL</button>
</div>

<script>

const canvas  = document.getElementById('c');
const ctx     = canvas.getContext('2d');
const BAR_H   = 80;
const VW      = window.innerWidth;
const VH      = window.innerHeight - BAR_H;

canvas.width  = VW;
canvas.height = VH;

let currentWord  = 'VIRAT';
let color1       = '#00e5ff';
let color2       = '#0055ff';
let fillPercent  = 0;
let waveTime     = 0;
let filling      = false;
let rafId        = null;
const bubbles    = [];

const maskC  = document.createElement('canvas');
maskC.width  = VW;
maskC.height = VH;
const mctx   = maskC.getContext('2d');

let FONT_SIZE, CX, CY, GLYPH_TOP, GLYPH_BOT, GLYPH_H;

function calcFontSize(word) {
  const maxW = VW * 0.88;
  const maxH = VH * 0.62;
  let size   = maxH;
  const tmp  = document.createElement('canvas');
  tmp.width  = VW; tmp.height = VH;
  const tc   = tmp.getContext('2d');

  let lo = 40, hi = Math.min(maxH, 360);
  for (let i = 0; i < 18; i++) {
    const mid = (lo + hi) / 2;
    tc.font = `${mid}px 'Bebas Neue', sans-serif`;
    if (tc.measureText(word).width <= maxW) lo = mid; else hi = mid;
  }
  return Math.floor(lo);
}

function setup(word) {
  FONT_SIZE = calcFontSize(word);
  CX = VW / 2;
  CY = VH / 2;

  mctx.clearRect(0, 0, VW, VH);
  mctx.fillStyle    = '#fff';
  mctx.font         = `${FONT_SIZE}px 'Bebas Neue', sans-serif`;
  mctx.textAlign    = 'center';
  mctx.textBaseline = 'middle';
  mctx.fillText(word, CX, CY);

  ctx.font = `${FONT_SIZE}px 'Bebas Neue', sans-serif`;
  const m  = ctx.measureText(word);
  GLYPH_TOP = CY - m.actualBoundingBoxAscent;
  GLYPH_BOT = CY + m.actualBoundingBoxDescent;
  GLYPH_H   = GLYPH_BOT - GLYPH_TOP;
}

function changeWord(word) {
  if (!word || word.trim() === '') return;
  word = word.toUpperCase().trim();
  currentWord = word;

  cancelAnimationFrame(rafId);
  filling     = false;
  fillPercent = 0;
  bubbles.length = 0;
  document.getElementById('fill-btn').textContent = 'FILL';
  document.getElementById('fill-btn').classList.remove('reset');

  setup(word);
  flashScreen();
  render();
  showToast(`"${word}" ready — pick a color & fill!`);
}

function flashScreen() {
  const f = document.getElementById('flash');
  f.style.background = 'rgba(255,255,255,0.07)';
  setTimeout(() => f.style.background = 'rgba(255,255,255,0)', 150);
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(t._tid);
  t._tid = setTimeout(() => t.classList.remove('show'), 2600);
}


document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    const cw = document.getElementById('custom-wrap');
    if (tab.id === 'custom-tab') {
      cw.style.display = 'flex';
      document.getElementById('custom-input').focus();
    } else {
      cw.style.display = 'none';
      changeWord(tab.dataset.word);
    }
  });
});


function applyCustom() {
  const val = document.getElementById('custom-input').value.trim();
  if (!val) { showToast('Please type a word first!'); return; }
  document.getElementById('custom-input').value = '';
  changeWord(val);
}

document.getElementById('custom-btn').addEventListener('click', applyCustom);
document.getElementById('custom-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') applyCustom();
});

document.getElementById('c1').addEventListener('input', e => {
  color1 = e.target.value;
  document.getElementById('sw1').style.background = color1;
  if (!filling) render();
});
document.getElementById('c2').addEventListener('input', e => {
  color2 = e.target.value;
  document.getElementById('sw2').style.background = color2;
  if (!filling) render();
});

document.getElementById('fill-btn').addEventListener('click', () => {
  const btn = document.getElementById('fill-btn');
  cancelAnimationFrame(rafId);
  if (fillPercent > 0) {
    fillPercent    = 0;
    filling        = false;
    bubbles.length = 0;
    btn.textContent = 'FILL';
    btn.classList.remove('reset');
    render();
    return;
  }
  filling = true;
  btn.textContent = 'RESET';
  btn.classList.add('reset');
  loop();
});

function loop() {
  fillPercent = Math.min(fillPercent + 0.065, 100);
  waveTime   += 0.022;

  if (fillPercent < 99 && Math.random() < 0.16) spawnBubble();

  updateBubbles();
  render();

  if (fillPercent < 100) {
    rafId = requestAnimationFrame(loop);
  } else {
    filling = false;
    document.getElementById('fill-btn').textContent = 'RESET';
    waveLoop();
  }
}

function waveLoop() {
  waveTime += 0.022;
  updateBubbles();
  render();
  rafId = requestAnimationFrame(waveLoop);
}

function spawnBubble() {
  const halfW = FONT_SIZE * currentWord.length * 0.28;
  bubbles.push({
    x:    CX + (Math.random() - 0.5) * halfW * 1.5,
    y:    GLYPH_BOT,
    r:    1.2 + Math.random() * 3.5,
    vy:   0.35 + Math.random() * 0.9,
    life: 1,
    wobble: Math.random() * Math.PI * 2,
  });
}

function updateBubbles() {
  const waterY = GLYPH_BOT - (fillPercent / 100) * GLYPH_H;
  for (let i = bubbles.length - 1; i >= 0; i--) {
    const b = bubbles[i];
    b.y    -= b.vy;
    b.x    += Math.sin(waveTime * 2.5 + b.wobble) * 0.5;
    b.life -= 0.007;
    if (b.y < waterY || b.life <= 0) bubbles.splice(i, 1);
  }
}

function hexToRgb(hex) {
  return [
    parseInt(hex.slice(1,3),16),
    parseInt(hex.slice(3,5),16),
    parseInt(hex.slice(5,7),16),
  ];
}
function darken(hex, a=0.45) {
  const [r,g,b] = hexToRgb(hex);
  return `rgb(${Math.round(r*a)},${Math.round(g*a)},${Math.round(b*a)})`;
}

function render() {
  ctx.clearRect(0, 0, VW, VH);

  const frac   = fillPercent / 100;
  const waterY = GLYPH_BOT - frac * GLYPH_H;

  if (fillPercent > 0) {
    const wOff  = document.createElement('canvas');
    wOff.width  = VW; wOff.height = VH;
    const wctx  = wOff.getContext('2d');

    const grad = wctx.createLinearGradient(0, waterY, 0, GLYPH_BOT);
    grad.addColorStop(0,   color1);
    grad.addColorStop(0.5, color2);
    grad.addColorStop(1,   darken(color2, 0.4));

    const amp   = fillPercent < 99 ? 8 : 0;
    const wL1   = VW * 0.46;
    const wL2   = VW * 0.26;

    wctx.beginPath();
    wctx.moveTo(0, VH);
    wctx.lineTo(0, waterY + amp * 1.3);
    for (let x = 0; x <= VW; x++) {
      const y = waterY + amp * 1.3
        + Math.sin((x / wL1) * Math.PI * 2 + waveTime + 1.4) * (amp * 0.6)
        + Math.sin((x / wL2) * Math.PI * 2 + waveTime * 1.4 + 2) * (amp * 0.3);
      wctx.lineTo(x, y);
    }
    wctx.lineTo(VW, VH);
    wctx.closePath();
    wctx.globalAlpha = 0.42;
    wctx.fillStyle   = color2;
    wctx.fill();
    wctx.globalAlpha = 1;

    wctx.beginPath();
    wctx.moveTo(0, VH);
    wctx.lineTo(0, waterY);
    for (let x = 0; x <= VW; x++) {
      const y = waterY
        + Math.sin((x / wL1) * Math.PI * 2 + waveTime) * amp
        + Math.sin((x / wL2) * Math.PI * 2 + waveTime * 1.7 + 0.9) * (amp * 0.4);
      wctx.lineTo(x, y);
    }
    wctx.lineTo(VW, VH);
    wctx.closePath();
    wctx.fillStyle = grad;
    wctx.fill();

    if (amp > 0) {
      wctx.beginPath();
      for (let x = 0; x <= VW; x++) {
        const y = waterY
          + Math.sin((x / wL1) * Math.PI * 2 + waveTime) * amp
          + Math.sin((x / wL2) * Math.PI * 2 + waveTime * 1.7 + 0.9) * (amp * 0.4);
        x === 0 ? wctx.moveTo(x, y - 2) : wctx.lineTo(x, y - 2);
      }
      for (let x = VW; x >= 0; x--) {
        const y = waterY
          + Math.sin((x / wL1) * Math.PI * 2 + waveTime) * amp
          + Math.sin((x / wL2) * Math.PI * 2 + waveTime * 1.7 + 0.9) * (amp * 0.4);
        wctx.lineTo(x, y + 5);
      }
      wctx.closePath();
      const sh = wctx.createLinearGradient(0, 0, VW, 0);
      sh.addColorStop(0,   'rgba(255,255,255,0)');
      sh.addColorStop(0.4, 'rgba(255,255,255,0.38)');
      sh.addColorStop(0.7, 'rgba(255,255,255,0.18)');
      sh.addColorStop(1,   'rgba(255,255,255,0)');
      wctx.fillStyle = sh;
      wctx.fill();
    }

    bubbles.forEach(b => {
      wctx.save();
      wctx.globalAlpha = b.life * 0.75;
      wctx.beginPath();
      wctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      wctx.strokeStyle = 'rgba(255,255,255,0.9)';
      wctx.lineWidth   = 1;
      wctx.stroke();
      wctx.beginPath();
      wctx.arc(b.x - b.r * 0.3, b.y - b.r * 0.3, b.r * 0.32, 0, Math.PI * 2);
      wctx.fillStyle = 'rgba(255,255,255,0.65)';
      wctx.fill();
      wctx.restore();
    });

    wctx.globalCompositeOperation = 'destination-in';
    wctx.drawImage(maskC, 0, 0);

    ctx.save();
    ctx.shadowColor = color1;
    ctx.shadowBlur  = 30 * frac;
    ctx.drawImage(wOff, 0, 0);
    ctx.restore();
    ctx.drawImage(wOff, 0, 0);
  }

  ctx.save();
  ctx.font         = `${FONT_SIZE}px 'Bebas Neue', sans-serif`;
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.lineJoin     = 'round';

  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth   = 24;
  ctx.strokeText(currentWord, CX, CY);

  ctx.strokeStyle = '#000';
  ctx.lineWidth   = 11;
  ctx.strokeText(currentWord, CX, CY);

  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth   = 3.5;
  ctx.strokeText(currentWord, CX, CY);
  ctx.restore();

  if (fillPercent > 0 && fillPercent < 100) {
    ctx.save();
    ctx.font      = `${Math.max(14, Math.round(FONT_SIZE * 0.075))}px 'Bebas Neue', sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.22)';
    ctx.textAlign = 'right';
    ctx.fillText(`${Math.round(fillPercent)}%`, VW - 20, VH - 16);
    ctx.restore();
  }
}

document.fonts.ready.then(() => {
  setup(currentWord);
  render();
});
</script>
</body>
</html>